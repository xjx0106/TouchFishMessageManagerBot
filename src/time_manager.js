const {
  getData,
  saveData,
  checkPermission,
} = require("../utils/index");
const bot = require('../index');
const {
  GOD_ID,
  TARGET_GROUP_ID
} = require("../config");
const dayjs = require("dayjs");

/**
 * Áï∂ÂâçÈ†ÅÁ¢ºÔºåËµ∑ÂßãÊñº1
 */
let page = 1;
/**
 * ÊôÇÈñìË°®ÁöÑË®àÊôÇÂô®
 */
let timer_status = null;

/**
 * Âü∫Á§édelta timeÊôÇÈñì
 */
let baseDelta = 1; // ÈÄôË£èÁµ¶ÁöÑÈªòË™çÂÄºÂÖ∂ÂØ¶ÊòØÊ≤íÁî®ÁöÑÔºåÈ†ÖÁõÆÂïìÂãïÂêéÔºåÊúÉÁî±setDeltaTime()ÊñπÊ≥ï‰æÜÂàùÂßãÂåñ
/**
 * ÊúÄÂ§ßÂÜçË∑≥ÊôÇÈñì
 */
let maxGrow = 0; // ÈÄôË£èÁµ¶ÁöÑÈªòË™çÂÄºÂÖ∂ÂØ¶ÊòØÊ≤íÁî®ÁöÑÔºåÈ†ÖÁõÆÂïìÂãïÂêéÔºåÊúÉÁî±setDeltaTime()ÊñπÊ≥ï‰æÜÂàùÂßãÂåñ
/**
 * Êñ∞Ê∂àÊÅØÁöÑÊôÇÈñìÊòØÂê¶Ëá™ÂãïÊãºÊé•‰∏äÂéª
 */
let autoSpilling = false;

/**
 * ÁÇ∫Ââ©È§òÁöÑÊ∂àÊÅØÊéíÊúü(callback)
 * @param {string} method ÊéíÂ∫èÊñπÂºè "rest" || "cover" || "clear" || "cancel"
 */
const scheduleTimeLine = async (method) => {
  console.log("[scheduleTimeLine]->", method);
  if (method === "cancel") {
    return;
  }
  const timeline = await getData("timeline");
  if (timeline.length) {
    timeline.forEach((item, index) => {
      if (method === "rest") {
        if (item.time) {
          // ÈÄôÂÄãÂ∑≤Á∂ìÊúâÊéíÊúü‰∫ÜÔºåÁõ¥Êé•‰∏ã‰∏ÄÂÄã
          // do nothing
        } else {
          // Ê≤íÂÆâÊéíÊôÇÈñìÔºåÂÖàÁúãÁúãÊòØÂê¶ÊúâÂâçÂ∫èÊ∂àÊÅØ
          if (index === 0) {
            // Ëá™Â∑±Â∞±ÊòØÈöäÈ¶ñ‰∫Ü
            const d = new Date();
            const t = d.getTime(); // Ê≠§ÊôÇ
            const time = generateRdmTime(t);
            item.time = time;
          } else {
            // ÂâçÈù¢ÊúâÂâçÂ∫è
            const prevItem = timeline[index - 1];
            const prevTime = prevItem.time;
            const time = generateRdmTime(prevTime);
            item.time = time;
          }
        }
      } else if (method === "cover") {
        if (index === 0) {
          // Ëá™Â∑±Â∞±ÊòØÈöäÈ¶ñ‰∫Ü
          const d = new Date();
          const t = d.getTime(); // Ê≠§ÊôÇ
          const time = generateRdmTime(t);
          item.time = time;
        } else {
          // ÂâçÈù¢ÊúâÂâçÂ∫è
          const prevItem = timeline[index - 1];
          const prevTime = prevItem.time;
          const time = generateRdmTime(prevTime);
          item.time = time;
        }
      } else if (method === "clear") {
        item.time = null;
      }
    });
    saveData(timeline, "timeline");
  } else {
    console.log("timeline has no length");
  }
  const res = await bot.sendMessage(GOD_ID, "Ë®àÂäÉÂÆåÊàêÔºÅ");
  setTimeout(() => {
    bot.deleteMessage(GOD_ID, res.message_id);
  }, 10000);
};

/**
 * ÁôºÈÄÅË®àÂäÉÂíåÁãÄÊÖã
 * @param {array} timeline ÊôÇÈñìÁ∂´
 * @param {number} messageId Ë¶Å‰øÆÊîπÁöÑÊ∂àÊÅØ
 */
const sendSchedule = async (timeline = null, messageId = null) => {
  clearTimeout(timer_status);
  timer_status = null;

  const PAGE_STAY_TIME = 25000;
  const PAGE_SIZE = 20;

  let _timeline = [];
  // ÂÖàÁúãÁúãÊúâÊ≤íÊúâËº∏ÂÖ•timelineÔºåËã•Ê≤íÊúâÔºåÈÇÑË¶ÅÂ∞àÈñÄÂéªÁç≤Âèñ‰∏Ä‰∏ã
  if (timeline) {
    _timeline = timeline;
  } else {
    _timeline = await getData("timeline");
  }
  const countScheduled = _timeline.filter(item => item.time).length;
  const countScheduled_not = _timeline.filter(item => !item.time).length;

  const runningStatus = timer ? "ÈöäÂàóÁãÄÊÖãÔºöÈÅãË°å üü¢\n----------------------------------------\n" : "ÈöäÂàóÁãÄÊÖãÔºöÊö´ÂÅú üî¥\n----------------------------------------\n";
  const scheduleStatus =
    "Áï∂ÂâçÈöäÂàóË£èÂÖ±Êúâ " +
    _timeline.length +
    " Ê¢ùÊ∂àÊÅØ„ÄÇ\n" +
    "Â∑≤Ë®àÂäÉÔºö" +
    countScheduled +
    " Ê¢ùÔºåÊú™Ë®àÂäÉÔºö" +
    countScheduled_not +
    " Ê¢ù\n\n";
  const timeLineText = _timeline.map(item => {
    let formatTime = "";
    if (item.time) {
      formatTime = dayjs(item.time).format("YYYY-MM-DD HH:mm:ss");

      const date = dayjs(item.time).format("YYYY-MM-DD");
      const nowDate = dayjs().format("YYYY-MM-DD");
      if (date === nowDate) {
        formatTime += " üî∏";
      }
    } else {
      formatTime = "Êú™Ë®àÂäÉ"
    }
    return formatTime;
  });

  if (!messageId) {
    page = 1;
  }

  const pageStartIndex = (page - 1) * PAGE_SIZE;
  const pageEndIndex = (page) * PAGE_SIZE;
  const timelineTextPaged = timeLineText.slice(pageStartIndex, pageEndIndex).map((item, idx) => '„Äê' + ((pageStartIndex + idx + 1) < 10 ? '0' : '') + (pageStartIndex + idx + 1) + "„Äë " + item);
  const pageInfo = "\n----------------------------------------\nÁï∂ÂâçÁ¨¨„Äê" + page + "„ÄëÈ†ÅÔºåÂÖ±„Äê" + Math.ceil(timeLineText.length / PAGE_SIZE) + "„ÄëÈ†Å";

  const totalText = runningStatus + scheduleStatus + "Ë®àÂäÉÂàóË°®Ôºö\n" + timelineTextPaged.join("\n") + pageInfo;
  if (!messageId) {
    // ÁôºÈÄÅË®àÂäÉÂàóË°®
    console.log("[ÁôºÈÄÅË®àÂäÉÂàóË°® first]->");
    const res = await bot.sendMessage(GOD_ID, totalText, {
      reply_markup: {
        inline_keyboard: [
          [{
              text: "È¶ñÈ°µ",
              callback_data: "TimeLinePage-1"
            },
            {
              text: "‰∏ä‰∏ÄÈ°µ",
              callback_data: "TimeLinePage-prev"
            },
            {
              text: "‰∏ã‰∏ÄÈ°µ",
              callback_data: "TimeLinePage-next"
            }
          ]
        ],
      }
    });
    timer_status = setTimeout(() => {
      // Êí§ÂõûË®àÂäÉÂàóË°®
      try {
        bot.deleteMessage(GOD_ID, res.message_id);
      } catch (error) {
        console.log('cannot delete schedule')
      }
    }, PAGE_STAY_TIME);
  } else {
    console.log("[editË®àÂäÉÂàóË°® first]->");
    await bot.editMessageText(totalText, {
      chat_id: GOD_ID,
      message_id: messageId,
      reply_markup: {
        inline_keyboard: [
          [{
              text: "È¶ñÈ°µ",
              callback_data: "TimeLinePage-1"
            },
            {
              text: "‰∏ä‰∏ÄÈ°µ",
              callback_data: "TimeLinePage-prev"
            },
            {
              text: "‰∏ã‰∏ÄÈ°µ",
              callback_data: "TimeLinePage-next"
            }
          ]
        ],
      }
    });
    timer_status = setTimeout(() => {
      // Êí§ÂõûË®àÂäÉÂàóË°®
      try {
        bot.deleteMessage(GOD_ID, messageId);
      } catch (error) {
        console.log('cannot delete schedule')
      }
    }, PAGE_STAY_TIME);
  }
};

/**
 * ÂàÜÈ†ÅÁôºÈÄÅÊôÇÈñìË°®
 * @param {array} timeline ÊôÇÈñìË°®ÔºåÂèØ‰ª•‰∏çÂÇ≥
 * @param {string} opreation Êìç‰ΩúÁ¨¶ÔºåÊúâ prev | next | 1
 * @param {number} messageId Ë¶Å‰øÆÊîπÁöÑÊ∂àÊÅØÁöÑid
 * 
 */
const pageSchedule = async (timeline = null, opreation, messageId) => {
  if (opreation === "prev") {
    page = page - 1;
    if (page < 1) {
      page = 1;
      return;
    } else {
      sendSchedule(null, messageId);
    }
  } else if (opreation === "next") {
    page = page + 1;
    sendSchedule(null, messageId);
  } else if (opreation === "1") {
    if (page === 1) {
      return;
    } else {
      page = 1;
      sendSchedule(null, messageId);
    }
  }
}

/**
 * ÁîüÊàê‰∏ÄÊÆµÈö®Ê©üÁöÑÊôÇÈï∑
 * @param {number} timestamp Âü∫ÊñºÁöÑÊôÇÈñì
 * @returns ÊôÇÈñìÊà≥
 */
const generateRdmTime = (timestamp) => {
  const _baseDelta = baseDelta * 60 * 1000; // Âü∫Á§édelta timeÊôÇÈñì
  const _maxGrow = maxGrow * 60 * 1000; // ÊúÄÂ§ßÂÜçË∑≥ÊôÇÈñì

  const amStart = "09:35:00";
  const amEnd = "12:00:00";
  const pmStart = "14:00:00";
  const pmEnd = "18:00:00";

  let result = 0;

  /**
   * Ê†πÊìö‰∏ÄÂÄãÊôÇÈñìÊà≥ÁîüÊàê‰∏ã‰∏ÄÂÄãÊôÇÈñì
   * @param {number} timestampInput Ê†πÊìöÁöÑÊôÇÈñì
   * @returns ‰∏ã‰∏ÄÂÄãÊôÇÈñìÊà≥
   */
  const goOnce = (timestampInput) => {
    let res = 0;
    const addedTime = parseInt((Math.random() * _maxGrow), 10); // Èö®Ê©üÁöÑÊñ∞Â¢ûÂá∫‰æÜÁöÑÊôÇÈñìÔºàÁ∏Ωdelta timeÔºâ
    res = timestampInput + _baseDelta + addedTime;
    return res;
  }

  /**
   * Ê†°È©óÊâÄÁîüÊàêÁöÑÊôÇÈñìÊòØÂê¶ÂêàÊ≥ïÔºåËøîÂõûÊ™¢Êü•ÁµêÊûú
   * @param {number} timestampInput Ë¶ÅÊ™¢Ê∏¨ÁöÑÊôÇÈñìÊà≥
   * @returns ÁãÄÊÖã
   * 
   * map:
   * 1: ‰∏äÂçàÔºå‰∏äÁè≠ÂâçÔºàÂ§™Êó©Ôºâ
   * 2: ‰∏äÂçàÔºåÂ∑•‰ΩúÊôÇ
   * 3: ‰∏≠ÂçàÔºåÂçà‰ºëÊôÇÔºàÂçà‰ºëÔºâ
   * 4: ‰∏ãÂçàÔºåÂ∑•‰ΩúÊôÇ
   * 5: ‰∏ãÂçàÔºå‰∏ãÁè≠ÂæåÔºà‰∏ãÁè≠‰∫ÜÔºâ
   */
  const checkTimeValid = timestampInput => {
    const time = dayjs(timestampInput).format("HH:mm:ss");

    const BEFORE_MORNING = 1;
    const MORNING = 2;
    const MIDDAY = 3;
    const AFTERNOON = 4;
    const AFTER_WORK = 5;

    let status = null;
    if (time < amStart) {
      status = BEFORE_MORNING;
    } else if (time >= amStart && time <= amEnd) {
      status = MORNING;
    } else if (time > amEnd && time < pmStart) {
      status = MIDDAY;
    } else if (time >= pmStart && time <= pmEnd) {
      status = AFTERNOON;
    } else if (time > pmEnd) {
      status = AFTER_WORK;
    } else {
      status = 9999;
    }
    return status;
  };

  /**
   * ÁîüÊàêÊôÇÈñìÂπ∂Âà§Êñ∑ÔºåÈÅûÊ≠∏
   */
  const genTime = (genTimeInput = null) => {
    let res = 0;
    // ÂñÆÊ¨°ÁîüÊàêÁöÑÁµêÊûú
    res = goOnce(genTimeInput);

    const check = checkTimeValid(res);
    if (check === 2 || check === 4) {
      return res;
    } else {
      return genTime(res);
    }
  }

  result = genTime(timestamp);
  return result;
};

/**
 * Ë®àÊôÇÂô®
 */
let timer = null;
/**
 * ÂÄíË®àÊôÇ‰∏ã‰∏ÄÊ¢ù
 * @param {function} function ÂõûË™øÂáΩÊï∏ÔºåÁôºÈÄÅÊ∂àÊÅØ
 */
const countDownNext = async (sendFn = null) => {
  console.log("Ë™øÁî®[ÂÄíË®àÊôÇ‰∏ã‰∏ÄÊ¢ù]");
  stopTimer();

  console.log("[Ë®àÁÆó‰∏ã‰∏ÄÊ¢ùÁöÑÊôÇÈñì]");
  const nextTime = await getNextTime();
  console.log("[‰∏ã‰∏ÄÊ¢ùÁöÑÊôÇÈñì]->", dayjs(nextTime).format("YYYY-MM-DD HH:mm:ss"));
  if (nextTime) {
    console.log("[ÈñãÂßãË®àÊôÇ!]");
    const d = new Date();
    const nowTime = d.getTime(); // now

    const deltaTime = nextTime - nowTime;
    timer = setTimeout(() => {
      console.log("[ÊôÇÈñìÂà∞!] Ê∫ñÂÇôË™øÁî®ÁôºÊ∂àÊÅØÊñπÊ≥ï");
      sendFn && sendFn();
    }, deltaTime);
  } else {
    stopTimer();
  }
}

/**
 * ÁôºÈÄÅÈöäÈ¶ñÊ∂àÊÅØ
 */
const sendMsg = async () => {
  console.log("ÈñãÂßãÁôºÊ∂àÊÅØ... sendMsg()");
  const timeline = await getData("timeline");

  let sendRes = null;
  if (timeline.length) {
    // ÂèØ‰ª•Áç≤ÂèñÈ¶ñÊ¢ùÊ∂àÊÅØ
    console.log("[ÂèØ‰ª•Áç≤ÂèñÈ¶ñÊ¢ùÊ∂àÊÅØ]");
    const one = timeline[0];
    if (one.isGroupMedia) {
      // ÊòØÂ™íÈ´îÁµÑ
      console.log("[ÊòØÂ™íÈ´îÁµÑ]");

      const messageIds = one.message_ids.map(mediaItem => mediaItem.msg_id);
      sendRes = await bot.copyMessages(TARGET_GROUP_ID, GOD_ID, messageIds);
      console.log("Â™íÈ´îÁµÑ ÁôºÈÄÅÂÆåÊàêÔºåÊ∫ñÂÇôÊ∏ÖÁêÜÈöäÂàóÈ¶ñÊ¢ù");
      // Âà™Èô§Â∞çË©±ÈöäÂàóË£èÁöÑÈÄôÊ¢ùÊ∂àÊÅØ
      try {
        const delRes = await bot.deleteMessages(GOD_ID, messageIds);
        console.log("[delRes]->", delRes);
      } catch (e) {
        console.log("error in deleting msg", e)
      }
      // Âà™Èô§timelineË£èÁöÑË©≤Ê∂àÊÅØÊï∏Êìö
      const timelineRest = timeline.filter((item, itemIdx) => itemIdx !== 0)
      saveData(timelineRest, "timeline");
    } else {
      // ÊòØÁ¥îÊñáÊú¨ÊàñÁç®Á´ãÂ™íÈ´î
      console.log("[ÊòØÁ¥îÊñáÊú¨ÊàñÁç®Á´ãÂ™íÈ´î]->");

      const messageId = one.message_id;
      sendRes = await bot.copyMessage(TARGET_GROUP_ID, GOD_ID, messageId);
      console.log("Áç®Á´ãÂ™íÈ´î ÁôºÈÄÅÂÆåÊàêÔºåÊ∫ñÂÇôÊ∏ÖÁêÜÈöäÂàóÈ¶ñÊ¢ù");
      // Âà™Èô§Â∞çË©±ÈöäÂàóË£èÁöÑÈÄôÊ¢ùÊ∂àÊÅØ
      try {
        const delRes = await bot.deleteMessage(GOD_ID, messageId);
        console.log("[delRes]->", delRes);
      } catch (e) {
        console.log("error in deleting msg", e)
      }
      // Âà™Èô§timelineË£èÁöÑË©≤Ê∂àÊÅØÊï∏Êìö
      const timelineRest = timeline.filter((item, itemIdx) => itemIdx !== 0)
      saveData(timelineRest, "timeline");
    }
    if (sendRes) {
      // ÁôºÂÆå‰∫ÜÂ∞±ÁπºÁ∫åÂÄíË®àÊôÇ‰∏ã‰∏ÄÊ¢ùÊ∂àÊÅØ
      countDownNext(sendMsg);
    }
  } else {
    console.log("[ÁÑ°Ê≥ïÁç≤ÂèñÈ¶ñÊ¢ùÊ∂àÊÅØ]->");
  }
}

/**
 * Áç≤Âèñ‰∏ã‰∏ÄÊ¢ùÊ∂àÊÅØÁöÑÁôºÈÄÅÊôÇÈñì
 * @returns ËøîÂõûÁç≤Âèñ‰∏ã‰∏ÄÊ¢ùÊ∂àÊÅØÁöÑÁôºÈÄÅÊôÇÈñìÔºåÂ¶ÇÊûúÁÇ∫0‰ª£Ë°®Ê≤íÊúâ‰∏ã‰∏ÄÊ¢ùÊ∂àÊÅØ‰∫Ü
 */
const getNextTime = async () => {
  let time = 0;

  const timeline = await getData("timeline");
  if (timeline.length) {
    const firstOne = timeline[0];
    const featureTime = firstOne.time;

    if (firstOne && featureTime) {
      time = featureTime;
    }
  }
  return time;
}

/**
 * ÂÅúÊ≠¢Ë®àÊôÇÂô®
 */
const stopTimer = () => {
  console.log("ÈñãÂßãÂÅúÊ≠¢Ë®àÊôÇÂô®");
  clearTimeout(timer);
  timer = null;
  console.log("Â∑≤Á∂ìÂÅúÊ≠¢Ë®àÊôÇÂô®");
}

/**
 * Ë®≠ÂÆöÂÖ®Â±ÄÈÖçÁΩÆ
 * @param {object} config ÂÖ®Â±ÄÈÖçÁΩÆ„ÄÇÂ¶ÇÊûúÊ≤íÊúâÔºåÂ∞±ÂæûdataË£èÂèñÂá∫‰æÜË®≠ÂÆöÂà∞ÂÖ®Â±ÄÔºõÂ¶ÇÊûúÊúâÔºåÂ∞±ÂêàÂπ∂„ÄÅ‰øùÂ≠ò„ÄÅ‰∏¶‰ª•Ê≠§Ë®≠ÂÆöÂà∞ÂÖ®Â±Ä
 */
const setConfig = async (config = null) => {
  let _data = await getData("config");
  if (config) {
    // ÊúâconfigÔºåÂ∞±Ë®≠ÂÆöÈÄ≤Âéªdata
    Object.assign(_data, config)
    saveData(_data, "config");
  }

  const {
    baseDelta: _b,
    maxGrow: _m,
    autoSpilling: _a
  } = _data;

  baseDelta = _b;
  maxGrow = _m;
  autoSpilling = _a;

  if (config) {
    const text = `‰øÆÊîπÊàêÂäüÔºÅ\n\nÂü∫Á§éÊôÇÈñìÔºö${baseDelta}\nÊúÄÂ§ßËµ∑Ë∑≥Ôºö${maxGrow}\nÊôÇÈñìËá™ÂãïÊãºÊé•Ôºö${autoSpilling}`;
    const res = await bot.sendMessage(GOD_ID, text);
    setTimeout(() => {
      bot.deleteMessage(GOD_ID, res.message_id);
    }, 5000);
  }
};

/**
 * ÈñãÂßãÈÅãË°åÈöäÂàó
 */
module.exports = bot.onText(/\/go/, onLoveText = async (msg) => {
  if (!checkPermission(msg)) {
    // ÁÑ°Ê¨äÈôêÔºå‰∏çÂÅöËôïÁêÜ
    return;
  }
  bot.deleteMessage(GOD_ID, msg.message_id);
  const res = await bot.sendMessage(GOD_ID, "ÈöäÂàóÈñãÂßãÈÅãË°åÔºÅüü¢");
  setTimeout(() => {
    bot.deleteMessage(GOD_ID, res.message_id);
  }, 6000);
  await countDownNext(sendMsg);
});
/**
 * ÂÅúÊ≠¢ÈÅãË°åÈöäÂàó
 */
module.exports = bot.onText(/\/stop/, onLoveText = async (msg) => {
  if (!checkPermission(msg)) {
    // ÁÑ°Ê¨äÈôêÔºå‰∏çÂÅöËôïÁêÜ
    return;
  }
  bot.deleteMessage(GOD_ID, msg.message_id);
  const res = await bot.sendMessage(GOD_ID, "ÈöäÂàóÂÅúÊ≠¢ÈÅãË°åÔºÅüî¥");
  setTimeout(() => {
    bot.deleteMessage(GOD_ID, res.message_id);
  }, 6000);
  stopTimer();
});

/**
 * Âü∑Ë°åËá™ÂãïÊéíÊúü
 */
module.exports = bot.onText(/\/manage/, onLoveText = async (msg) => {
  if (!checkPermission(msg)) {
    // ÁÑ°Ê¨äÈôêÔºå‰∏çÂÅöËôïÁêÜ
    return;
  }
  // Âà™Èô§Êåá‰ª§
  bot.deleteMessage(GOD_ID, msg.message_id);
  sendScheduleCommands();
});

/**
 * ÁôºÈÄÅË®àÂäÉË°®
 */
module.exports = bot.onText(/\/status/, onLoveText = async (msg) => {
  if (!checkPermission(msg)) {
    // ÁÑ°Ê¨äÈôêÔºå‰∏çÂÅöËôïÁêÜ
    return;
  }
  bot.deleteMessage(GOD_ID, msg.message_id);

  sendSchedule(null, null);
});

/**
 * Ë®≠ÂÆöÊôÇÈñìÈñìÈöî
 */
module.exports = bot.onText(/\/time/, onLoveText = async (msg) => {
  if (!checkPermission(msg)) {
    // ÁÑ°Ê¨äÈôêÔºå‰∏çÂÅöËôïÁêÜ
    return;
  }
  bot.deleteMessage(GOD_ID, msg.message_id);

  const params = (msg.text + "").replace("/time", "").split(" ");
  console.log("[params]->", params);
  try {
    if (params.length === 3) {
      const p1 = Number(params[1]);
      console.log("[p1]->", p1);
      const p2 = Number(params[2]);
      console.log("[p2]->", p2);

      if (isNaN(p1) || isNaN(p2)) {
        // Â¶ÇÊûúp1Êàñp2‰∏çÊòØÊï∏Â≠ó
        const res = await bot.sendMessage(GOD_ID, "time ÂèÉÊï∏‰∏çÊòØÊï∏Â≠ó!");
        setTimeout(() => {
          bot.deleteMessage(GOD_ID, res.message_id);
        }, 5000);
      } else {
        setConfig({
          baseDelta: p1,
          maxGrow: p2
        });
      }
    } else if (params.length === 1) {
      const text = `Ê≠§ÊôÇÁöÑÂèÉÊï∏ÊòØÔºö\n\nÂü∫Á§éÊôÇÈñìÔºö${baseDelta}\nÊúÄÂ§ßËµ∑Ë∑≥Ôºö${maxGrow}`;
      const res = await bot.sendMessage(GOD_ID, text);
      setTimeout(() => {
        bot.deleteMessage(GOD_ID, res.message_id);
      }, 5000);
    } else {
      const res = await bot.sendMessage(GOD_ID, "time ÂèÉÊï∏Êï∏Èáè‰∏çÂåπÈÖç!");
      setTimeout(() => {
        bot.deleteMessage(GOD_ID, res.message_id);
      }, 5000);
    }
  } catch (error) {
    console.log("[error in try, get params in time]->", error);
  }
});

/**
 * Ë®≠ÂÆöÊôÇÈñìÊòØÂê¶Ëá™ÂãïÊãºÊé•
 */
module.exports = bot.onText(/\/auto/, onLoveText = async (msg) => {
  if (!checkPermission(msg)) {
    // ÁÑ°Ê¨äÈôêÔºå‰∏çÂÅöËôïÁêÜ
    return;
  }
  bot.deleteMessage(GOD_ID, msg.message_id);

  const params = (msg.text + "").replace("/auto", "").split(" ");
  console.log("[params]->", params, params.length);
  try {
    if (params.length === 2) {
      const p1 = JSON.parse(params[1]);
      console.log("[p1]->", p1);

      if (p1 !== true && p1 !== false) {
        // Â¶ÇÊûúp1‰∏çÊòØÊï∏Â≠ó
        const res = await bot.sendMessage(GOD_ID, "auto ÂèÉÊï∏‰∏çÊòØtrueÊàñfalse!");
        setTimeout(() => {
          bot.deleteMessage(GOD_ID, res.message_id);
        }, 5000);
      } else {
        setConfig({
          autoSpilling: p1
        });
      }
    } else if (params.length === 1) {
      const text = `Ê≠§ÊôÇÁöÑÂèÉÊï∏ÊòØÔºö\n\n ÊòØÂê¶Ëá™ÂãïÊãºÊé•Ôºö${autoSpilling}`;
      const res = await bot.sendMessage(GOD_ID, text);
      setTimeout(() => {
        bot.deleteMessage(GOD_ID, res.message_id);
      }, 5000);
    } else {
      const res = await bot.sendMessage(GOD_ID, "time ÂèÉÊï∏Êï∏Èáè‰∏çÂåπÈÖç!");
      setTimeout(() => {
        bot.deleteMessage(GOD_ID, res.message_id);
      }, 5000);
    }
  } catch (error) {
    console.log("[error in try, get params in auto]->", error);
  }
});

/**
 * ÁôºÈÄÅÊéíÊúüÁöÑÊåá‰ª§
 */
const sendScheduleCommands = () => {
  bot.sendMessage(GOD_ID, "ÈÄâÊã©Ë¶ÅÊéíÂ∫èÁöÑÊ®°Âºè", {
    parse_mode: "HTML",
    reply_markup: {
      inline_keyboard: [
        [{
            text: "È§òÈáèÊéíÊúü",
            callback_data: "TimeLine-rest"
          },
          {
            text: "ÂÖ®ÈáèÈáçÊéí",
            callback_data: "TimeLine-cover"
          },
          {
            text: "Ê∏ÖÈô§ÊéíÊúü",
            callback_data: "TimeLine-clear"
          },
        ],
        [{
          text: "ÂèñÊ∂à",
          callback_data: "TimeLine-cancel"
        }]
      ],
    },
  });
};

setConfig();

module.exports = {
  scheduleTimeLine, // Â∞éÂá∫Áµ¶callbackË™øÁî®
  pageSchedule, // // Â∞éÂá∫Áµ¶callbackË™øÁî®
  generateRdmTime, // Â∞éÂá∫Áµ¶message_managerË™øÁî®
  autoSpilling // Â∞éÂá∫Áµ¶message_manager‰ΩøÁî®
};